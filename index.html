<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry - shapes</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="style.css" />
    <style>
      body {
        background-color: #f0f0f0;
        color: #444;
      }
    </style>
    <script src="script.js"></script>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://threejs.org/build/three.module.js';

      import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';
      import { Line2 } from 'https://threejs.org/examples/jsm/lines/Line2.js';
      import { OrbitControls } from 'https://threejs.org/examples/jsm/controls/OrbitControls.js';
      import { LineMaterial } from 'https://threejs.org/examples/jsm/lines/LineMaterial.js';
      import { LineGeometry } from 'https://threejs.org/examples/jsm/lines/LineGeometry.js';
      let container, stats;
      let camera, scene, raycaster, renderer, group, sphereInter;

      const pointer = new THREE.Vector2();
      const radius = 1;
      let theta = 0;

      const mapUrl = 'https://mehlko.github.io/geosim/maps/bisholder.json';

      const nodeMap = new Map();
      const wayMap = new Map();
      var bounds = {};

      var matLine = new LineMaterial({
        color: 0xff0000,
        linewidth: 0.01,
      });
      loadMap();
      init();
      animate();

      function loadMap() {
        fetch(mapUrl)
          .then((response) => response.json())
          .then((data) => {
            bounds = data.bounds;
            data.elements.map((element) => {
              if (element.type == 'node') {
                nodeMap.set(element.id, element);
              }
              if (element.type == 'way') {
                wayMap.set(element.id, element);
              }
            });

            console.log('Loading done:', data);
            console.log('Bounds:', bounds);
            console.log('Nodes:', nodeMap.size);
            console.log('Way:', wayMap.size);
          })
          .catch((error) => {
            console.error('Error:', error);
          });
      }

      function init() {
        container = document.createElement('div');
        document.body.appendChild(container);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        stats = new Stats();
        container.appendChild(stats.dom);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        scene.add(new THREE.GridHelper(2, 100));
        scene.add(new THREE.AxesHelper(1));


        console.log(wayMap.size);
        wayMap.forEach((way) => {
          console.log(way);
        });

        group = new THREE.Object3D();
        scene.add(group);

        let line = getLine(0, 0, 0, 1);
        group.add(line);

        //event listeners

        window.addEventListener('resize', onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function getLine(x1, y1, x2, y2) {
        const points = [];
        points.push(new THREE.Vector3(x1, 0, y1));
        points.push(new THREE.Vector3(x2, 0, y2));

        const geometry = new LineGeometry();
        geometry.fromLine(
          new THREE.Line(new THREE.BufferGeometry().setFromPoints(points))
        );
        return new Line2(geometry, matLine);
      }

      function animate() {
        requestAnimationFrame(animate);

        render();
        stats.update();
      }

      function render() {
        theta += 0.1;

        camera.position.x = radius * Math.sin(THREE.MathUtils.degToRad(theta));
        camera.position.y = radius * Math.sin(THREE.MathUtils.degToRad(theta));
        camera.position.z = radius * Math.cos(THREE.MathUtils.degToRad(theta));
        camera.lookAt(scene.position);

        camera.updateMatrixWorld();

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
