<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry - shapes</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="style.css" />
    <style>
      body {
        background-color: #f0f0f0;
        color: #444;
      }
    </style>
    <script src="script.js"></script>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://threejs.org/build/three.module.js';

      import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';
      import { Line2 } from 'https://threejs.org/examples/jsm/lines/Line2.js';
      import { OrbitControls } from 'https://threejs.org/examples/jsm/controls/OrbitControls.js';
      import { LineMaterial } from 'https://threejs.org/examples/jsm/lines/LineMaterial.js';
      import { LineGeometry } from 'https://threejs.org/examples/jsm/lines/LineGeometry.js';
      let container, stats;
      let camera, scene, raycaster, renderer, group, controls;

      const pointer = new THREE.Vector2();
      const radius = 1;
      let theta = 0;

      const mapUrl = 'https://mehlko.github.io/geosim/maps/bisholder.json';

      //map
      var bounds = {};
      const nodeMap = new Map();
      const wayMap = new Map();

      var matLine = new LineMaterial({
        color: 0xff0000,
        linewidth: 0.002,
      });

      async function loadMap() {
        var response = await fetch(mapUrl);
        var json = await response.json();
        bounds = json.bounds;
        json.elements.map((element) => {
          if (element.type == 'node') {
            nodeMap.set(element.id, element);
          }
          if (element.type == 'way') {
            wayMap.set(element.id, element);
          }
        });

        console.log('Loading done:', json);
        console.log('Bounds:', bounds);
        console.log('Nodes:', nodeMap.size);
        console.log('Way:', wayMap.size);
      }

      init();
      animate();

      async function init() {
        container = document.createElement('div');
        document.body.appendChild(container);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        stats = new Stats();
        container.appendChild(stats.dom);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(1, 1, 1);

        /*
        renderer.clippingPlanes = [
          new THREE.Plane(new THREE.Vector3(0.51, 0, 0), 1),
          new THREE.Plane(new THREE.Vector3(-0.51, 0, 0), 1),
          new THREE.Plane(new THREE.Vector3(0, 0, 0.51), 1),
          new THREE.Plane(new THREE.Vector3(0, 0, -0.51), 1),
        ];
*/
        // controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional

        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;

        controls.screenSpacePanning = false;

        controls.minDistance = 0.2;
        controls.maxDistance = 100;

        controls.maxPolarAngle = Math.PI / 2;

        scene = new THREE.Scene();
        scene.position.x = -0.5;
        scene.position.z = -0.5;
        scene.background = new THREE.Color(0xf0f0f0);
        let grid = new THREE.GridHelper(1, 10);
        grid.position.x = +0.5;
        grid.position.z = +0.5;
        scene.add(grid);

        let axes = new THREE.AxesHelper(0.1);
        scene.add(axes);

        group = new THREE.Object3D();

        scene.add(group);

        await loadMap();
        var scaleX = bounds.maxlat - bounds.minlat;
        var scaleY = bounds.maxlon - bounds.minlon;
        group.position.x = -bounds.minlat / scaleX;
        group.position.z = -bounds.minlon / scaleY;
        group.scale.x = 1 / scaleX;
        group.scale.z = 1 / scaleY;

        console.log('MyWays', wayMap.size);

        wayMap.forEach((way) => {
          let line = getPath(way);
          group.add(line);
          let line2 = getPath2(way);
          console.log(line2);
          group.add(line2);
        });

        //event listeners

        window.addEventListener('resize', onWindowResize);
      }

      function getPath(path) {
        const points = [];
        path.nodes.map((nodeId) => {
          var node = nodeMap.get(nodeId);

          points.push(new THREE.Vector3(node.lat, 0, node.lon));
        });

        const geometry = new LineGeometry();
        geometry.fromLine(
          new THREE.Line(new THREE.BufferGeometry().setFromPoints(points))
        );
        var line = new Line2(geometry, matLine);

        return line;
      }

      function getPath2(path) {
        const points = [];
        path.nodes.map((nodeId) => {
          var node = nodeMap.get(nodeId);
          points.push(new THREE.Vector2(node.lat, node.lon));
        });

        const extrudeSettings = {
          depth: 1,
          steps: 1,
          bevelEnabled: true,
          bevelThickness: 1,
          bevelSize: 1,
          bevelSegments: 1,
        };
        var shape = new THREE.Shape(points);
        var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

        var mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshPhongMaterial({ color: 0xff0000 })
        );

        console.log(mesh);
        return mesh;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
        render();
        stats.update();
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
